;; Numbers
(define expt #f)
(define make-rectangular #f)
(define make-polar #f)
(define magnitude #f)
(define angle #f)
(define inexact #f)
;; Booleans
(define not #f)
(define boolean=? #f)
;; Characters
(define char=? #f)
(define char<? #f)
(define char>? #f)
(define char<=? #f)
(define char>=? #f)
(define char-ci=? #f)
(define char-ci<? #f)
(define char-ci>? #f)
(define char-ci<=? #f)
(define char-ci>=? #f)
;; Strings
(define string=? #f)
(define string-ci=? #f)
(define string<? #f)
(define string-ci<? #f)
(define string>? #f)
(define string-ci>? #f)
(define string<=? #f)
(define string-ci<=? #f)
(define string>=? #f)
(define string-ci>=? #f)

((lambda (;; Equivalence predicates
          c-eqv? c-eq?
                 ;; Numbers
                 c-complex? c-exact? c-finite? c-infinite? c-nan? c-+ c-* c-
                 c-/ c-gcd c-lcm c-numerator c-denominator c-floor c-ceiling
                 c-truncate c-round c-exp c-log c-sin c-cos c-tan c-asin c-acos
                 c-atan c-sqrt c-real-part c-imag-part c-exact
                 c-number->string c-string->number
                 ;; Booleans
                 c-boolean?
                 ;; Pairs and lists
                 c-pair? c-cons c-car c-cdr c-set-car! c-set-cdr!
                 ;; Symbols
                 c-symbol=?
                 ;; Characters
                 c-char? c-char-alphabetic? c-char-numeric? c-char-whitespace?
                 c-char-upper-case? c-char-lower-case? c-digit-value
                 c-char->integer c-integer->char c-char-upcase c-char-downcase
                 c-char-foldcase
                 ;; Strings
                 c-string? c-make-string? c-string-length c-string-ref
                 c-string-set!

                 ;; Control features
                 c-procedure?

                 ;; Exceptions
                 c-error
                 ;; Input and output
                 c-input-port? c-output-port? c-textual-port? c-binary-port?
                 c-open-input-file c-open-binary-input-file
                 c-open-output-file c-open-binary-output-file
                 c-close-port
                 c-read
                 c-write
                 )
   
   
   (define (length-> name args n)
     (if (not (> (length args) n)) (error-args name args)))
   (define (error-args proc-name args)
     (error "wrong number of arguments -- " proc-name args))
   (define (error-type proc-name args)
     (error "wrong type of argument --" proc-name args))
   (define (length-= name args k)
     (if (not (= (length args) k)) (error-args name args)))
   (define (proc-one name type? proc)     
     (lambda args
       (length-= name args 1)
       ((lambda (o)
          (if (type? o)
              (proc o)
              (error-type name args)))
        (car args))))
   (define proc-true (lambda args #t))
   (define (proc-set-cr! name proc)
     (lambda args
       (length-= name args 2)
       ((lambda (pair obj)
          (if (pair? pair)
              (proc pair obj)
              (error-type name args)))
        (car args) (cadr args))))
   (define (char-cmp proc-name cmp ci)
     (lambda args
       (length-> proc-name args 2)
       ((lambda ()
          (define (iter c rest)
            ((lambda (c0)
               (if (char? c0)
                   (if (cmp (ci (char->integer c)) (ci (char->integer c0)))
                       (if (null? rest)
                           #t
                           (iter c0 (cdr rest)))
                       #f)
                   (error-type 'proc-name args)))
             (car rest)))
          ((lambda (c)
             (if (char? c)
                 (iter c (cdr args))
                 (error-type 'char=? args)))
           (car args))))))
   (define (id o) o)
   (define (char-proc name c-proc)
     (lambda args
       (length-= name args 1)
       ((lambda (c)
          (if (char? c)
              (c-proc c)
              (error-type name args)))
        (car args))))
   (define (string-cmp proc-name char-cmp)
     (lambda args
       (length-> proc-name args 2)
       ((lambda ()
          (define (inner s1 s2)
            (define n (max (string-length s1) (string-length s2)))
            (define (iter i)
              (if (>= i n)
                  #t
                  (if (char-cmp (string-ref s1 i) (string-ref s2 i))
                      (iter (+ i 1))
                      #f)))
            (iter 0))
          (define (iter s rest)
            (if (null? rest)
                #t
                ((lambda (s0)
                   (if (string? s0)
                       (if (inner s s0)
                           (iter s0 (cdr rest))
                           #f)
                       (error-type proc-name args)))
                 (car rest))))
          ((lambda (s rest)
             (if (string? s)
                 (iter s rest)
                 (error-type proc-name args)))
           (car args) (cdr args))))))
   ;; Equivalence predicates   
   (set! eqv?
         (lambda args
           (length-= 'eqv? args 2)
           ((lambda (obj1 obj2)
              (if (and (boolean? obj1) (boolean? obj2))
                  (or (and obj1 obj2)
                      (and (not obj1) (not obj2)))
                  (if (and (symbol? obj1) (symbol? obj2))
                      (symbol=? obj1 obj2)
                      (if (and (number? obj1) (number? obj2))
                          (if (or (and (inexact? obj1) (inexact? obj1))
                                  (and (exact? obj1) (exact? obj2)))
                              (= obj1 obj2)
                              #f)
                          (if (and (char? obj1) (char? obj2))
                              (char=? obj1 obj2)
                              (if (and (null? obj1) (null? obj2))
                                  #t
                                  (c-eqv? obj1 obj2)))))))
            (car args) (cadr args))))
   (set! eq?
         (lambda args
           (length-= 'eq? args 2)
           ((lambda (obj1 obj2)
              (if (or (symbol? obj1)
                      (boolean? obj1)
                      (null? obj1)
                      (pair? obj1)
                      (and (string? obj1) (not (eqv? obj1 "")))
                      (and (vector? obj1) (not (eqv? obj1 #())))
                      (and (bytevector? obj1) (not (eqv? obj1 #u8())))
                      (procedure? obj1))
                  (eqv? obj1 obj2)
                  (c-eq? obj1 obj2)))
            (car args) (cadr args))
           (error-args 'eq? args)))

   ;; Numbers
   (set! number? (proc-one 'number? proc-true c-complex?))
   (set! exact? (proc-one 'exact? complex? c-exact?))
   (set! finite? (proc-one 'finite? complex? c-finite?))
   (set! infinite? (proc-one 'infinite? complex? c-infinite?))
   (set! nan? (proc-one 'nan? complex? c-nan?))
   (set! + (lambda zs
             (define (iter zs0 result)
               (if (null? zs0)
                   result
                   ((lambda (z)
                      (if (complex? z)
                          (if (or (inexact? result) (inexact? z))
                              (iter (cdr zs0)
                                    (c-+ (inexact result) (inexact z)))
                              (iter (cdr zs0) (c-+ result z)))
                          (error-type '+ zs)))
                    (car zs0))))
             (iter zs 0)))
   (set! * (lambda zs
             (define (iter zs0 result)
               (if (null? zs0)
                   result
                   ((lambda (z)
                      (if (complex? z)
                          (if (or (inexact? result) (inexact? z))
                              (iter (cdr zs0) (c-* (inexact result)
                                                   (inexact z)))
                              (iter (cdr zs0) (c-* result z)))
                          (error-type '* zs)))
                    (car zs0))))
             (iter zs 1)))
   (set! - (lambda args
             (length-> '- args 0)
             ((lambda (z rest)
                (if (null? rest)
                    (if (complex? z)
                        (* -1 z)
                        (error-type '- args))
                    ((lambda ()
                       (define (iter zs result)
                         (if (null? zs)
                             result
                             ((lambda (z)
                                (if (complex? z)
                                    (if (or (inexact? result) (inexact? z))
                                        (iter (cdr zs) (c-- (inexact result)
                                                            (inexact z)))
                                        (iter (cdr zs) (c-- result z)))
                                    (error-type '- args)))
                              (car zs))))
                       (if (complex? z)
                           (iter rest z)
                           (error-type '- args))))))
              (car args) (cdr args))))
   (set! / (lambda args
             (length-> '/ args 0)
             ((lambda (z rest)
                (if (null? rest)
                    (if (complex? z)
                        (if (and (exact? z) (zero? z))
                            (error "division by zero")
                            (c-/ 1 z))
                        (error-type '/ args))
                    ((lambda ()
                       (define (iter zs result)
                         (if (null? zs)
                             result
                             ((lambda (z)
                                (if (complex? z)
                                    (if (or (inexact? result) (inexact? z))
                                        (iter (cdr zs) (c-/ (inexact result)
                                                            (inexact z)))
                                        (if (zero? z)
                                            (error "division by zero")
                                            (iter (cdr zs) (c-/ result z))))
                                    (error-type '/ args)))
                              (car zs))))
                       (if (complex? z)
                           (iter rest z)
                           (error-type '/ args))))))
              (car args) (cdr args))))
   
   (set! gcd (lambda ns
               (define proc exact)
               (define (iter ns result)
                 (if (null? ns)
                     result
                     ((lambda (n)
                        (if (integer? n)
                            (if (exact? n)
                                (iter (cdr ns) (c-gcd result n))
                                ((lambda ()
                                   (set! proc inexact)
                                   (iter (cdr ns) (c-gcd result (exact n))))))
                            (error-type 'gcd ns)))
                      (car ns))))
               (proc (iter ns 0))))
   (set! lcm (lambda ns
               (define proc exact)
               (define (iter ns result)
                 (if (null? ns)
                     result
                     ((lambda (n)
                        (if (integer? n)
                            (if (exact? n)
                                (iter (cdr ns) (c-lcm result n))
                                ((lambda ()
                                   (set! proc inexact)
                                   (iter (cdr ns) (c-lcm result (exact n))))))
                            (error-type 'lcm ns)))
                      (car ns))))
               (proc (iter ns 1))))
   (set! numerator (lambda args (length-= 'numerator args 1)
                           ((lambda (o)
                              (if (rational? o)
                                  (if (exact? o)
                                      (c-numerator o)
                                      (inexact
                                       (c-numerator (exact o))))
                                  (error-type 'numerator args)))
                            (car args))))
   (set! denominator (lambda args (length-= 'denominator args 1)
                             ((lambda (o)
                                (if (rational? o)
                                    (if (exact? o)
                                        (c-denominator o)
                                        (inexact
                                         (c-denominator (exact o))))
                                    (error-type 'denominator args)))
                              (car args))))
   (set! floor (lambda args (length-= 'floor args 1)
                       ((lambda (o)
                          (if (real? o)
                              (c-floor o)
                              (error-type 'floor args)))
                        (car args))))
   (set! ceiling (lambda args (length-= 'ceiling args 1)
                         ((lambda (o)
                            (if (real? o)
                                (c-ceiling o)
                                (error-type 'ceiling args)))
                          (car args))))
   (set! truncate (lambda args (length-= 'truncate args 1)
                          ((lambda (o)
                             (if (real? o)
                                 (c-truncate o)
                                 (error-type 'truncate args)))
                           (car args))))
   (set! round (lambda args (length-= 'round args 1)
                       ((lambda (o)
                          (if (real? o)
                              (c-round o)
                              (error-type 'round args)))
                        (car args))))
   (set! exp (lambda args
               (length-= 'exp args 1)
               ((lambda (z)
                  (if (complex? z)
                      (c-exp z)
                      (error-type 'exp args)))
                (car args))))
   (set! log (lambda args
               ((lambda (len)
                  (if (= len 1)
                      ((lambda (z)
                         (if (complex? z)
                             (c-log z)
                             (error-type 'log args)))
                       (car args))
                      (if (= len 2)
                          ((lambda (z1 z2)
                             (if (and (complex? z1) (complex? z2))
                                 (/ (log z1) (log z2))
                                 (error-type 'log args)))
                           (car args) (cadr args))
                          (error-args 'log args))))
                (length args))))
   (set! sin (lambda args (length-= 'sin args 1)
                     ((lambda (z)
                        (if (complex? z)
                            (c-sin z)
                            (error-type 'sin args)))
                      (car args))))
   (set! cos (lambda args (length-= 'cos args 1)
                     ((lambda (z)
                        (if (complex? z)
                            (c-cos z)
                            (error-type 'cos args)))
                      (car args))))
   (set! tan (lambda args (length-= 'tan args 1)
                     ((lambda (z)
                        (if (complex? z)
                            (c-tan z)
                            (error-type 'tan args)))
                      (car args))))
   (set! asin (lambda args (length-= 'asin args 1)
                      ((lambda (z)
                         (if (complex? z)
                             (c-asin z)
                             (error-type 'asin args)))
                       (car args))))
   (set! acos (lambda args (length-= 'acos args 1)
                      ((lambda (z)
                         (if (complex? z)
                             (c-acos z)
                             (error-type 'acos args)))
                       (car args))))
   (set! atan (lambda args
                ((lambda (len)
                   (if (= len 1)
                       ((lambda (z)
                          (if (complex? z)
                              (c-atan z)
                              (error-type 'atan args)))
                        (car args))
                       (if (= len 2)
                           ((lambda (y x)
                              (if (and (real? y) (real? x))
                                  (angle (make-rectangular x y))
                                  (error-type 'atan args)))
                            (car args) (cadr args))
                           (error-args 'atan args))))
                 (length args))))
   (set! sqrt (lambda args (length-= 'sqrt args 1)
                      ((lambda (z)
                         (if (complex? z)
                             (c-sqrt z)
                             (error-type 'sqrt args)))
                       (car args))))
   (set! expt
         (lambda args (length-= 'expt args 2)
                 ((lambda (z1 z2)
                    (if (and (complex? z1) (complex? z2))
                        (if (zero? z1)
                            (if (zero? z2)
                                (if (and (exact? z1) (exact? z2)) 1 1.0)
                                (if (positive? (real-part z2))
                                    (if (and (exact? z1) (exact? z2)) 0 0.0)
                                    (error "division by zero")))
                            (if (and (exact? z1) (exact-integer? z2))
                                ((lambda ()
                                   (define b (positive? z2))
                                   (define op1 (if b - +))
                                   (define op2 (if b * /))
                                   (define (iter n result)
                                     (if (zero? n)
                                         result
                                         (iter (op1 n 1) (op2 result z1))))
                                   (iter z2 1)))
                                (exp (* z2 (log z1)))))
                        (error-type 'expt args)))
                  (car args) (cadr args))))
   (set! make-rectangular (lambda args (length-= 'make-rectangular args 2)
                                  ((lambda (x1 x2)
                                     (if (and (real? x1) (real? x2))
                                         (+ x1 (* x2 +i))
                                         (error-type 'make-rectangular args)))
                                   (car args) (cadr args))))
   (set! make-polar (lambda args (length-= 'make-polar args 2)
                            ((lambda (x1 x2)
                               (if (and (real? x1) (real? x2))
                                   (* x1 (exp (* +i x2)))
                                   (error-type 'make-polar args)))
                             (car args) (cadr args))))
   (set! real-part (lambda args (length-= 'real-part args 1)
                           ((lambda (z)
                              (if (real? z)
                                  z
                                  (if (complex? z)
                                      (c-real-part z)
                                      (error-type 'real-part args))))
                            (car args))))
   (set! imag-part (lambda args (length-= 'imag-part args 1)
                           ((lambda (z)
                              (if (real? z)
                                  0
                                  (if (complex? z)
                                      (c-imag-part z)
                                      (error-type 'imag-part args))))
                            (car args))))
   (set! magnitude (lambda args (length-= 'magnitude args 1)
                           ((lambda (z)
                              (if (real? z)
                                  (abs z)
                                  (if (complex z)
                                      (sqrt (+ (expt (real-part z) 2)
                                               (expt (imag-part z) 2)))
                                      (error-type 'magnitude args))))
                            (car args))))
   (set! angle (lambda args (length-= 'angle args 1)
                       ((lambda (z)
                          (if (complex? z)
                              (acos (/ (real-part z) (magnitude z)))
                              (error-type 'angle args)))
                        (car args))))
   (set! inexact (lambda args (length-= 'inexact args 1)
                         ((lambda (z)
                            (if (complex? z)
                                (if (exact? z) (* 1.0 z) z)
                                (error-type 'inexact args)))
                          (car args))))
   (set! exact (lambda args (length-= exact args 1)
                       ((lambda (z)
                          (if (complex? z)
                              (if (exact? z)
                                  z
                                  (if (or (nan? z) (infinite? z))
                                      (error-type 'exact args)
                                      (c-exact z)))
                              (error-type 'exact args)))
                        (car args))))
   (set! number->string
         (lambda args
           ((lambda (len)
              (if (= len 1)
                  ((lambda (z)
                     (if (complex? z)
                         (c-number->string z 10)
                         (error-type 'number->string args)))
                   (car args))
                  (if (= len 2)
                      ((lambda (z radix)
                         (if (and (complex? z)
                                  (exact-integer? radix)
                                  (or (= radix 2)
                                      (= radix 8)
                                      (= radix 10)
                                      (= radix 16)))
                             (number->string z radix)
                             (error-type 'number->string args)))
                       (car args) (cadr args))
                      (error-args 'number->string args))))
            (length args))))
   (set! string->number
         (lambda args
           ((lambda (len)
              (if (= len 1)
                  ((lambda (string)
                     (if (string? string)
                         (c-string->number string 10)
                         (error-type 'string->number args)))
                   (car args))
                  (if (= len 2)
                      ((lambda (string radix)
                         (if (and (string? string)
                                  (exact? radix)
                                  (or (= radix 2)
                                      (= radix 8)
                                      (= radix 10)
                                      (= radix 16)))
                             (c-string->number string radix)
                             (error-type 'string->number args)))
                       (car args) (cadr args))
                      (error-args 'string->number args))))
            (length args))))

   (set! symbol=?
         (lambda args
           (define sym (car args))
           (length-> 'symbol=? args 1)           
           (if (symbol? sym)
               ((lambda ()
                  (define (iter rest)
                    (if (null? rest)
                        #t
                        ((lambda (s)
                           (if (symbol? s)
                               (if (c-symbol=? sym s) (iter (cdr rest)) #f)
                               (error-type 'symbol=? args)))
                         (car rest))))
                  (iter (cdr args))))
               (error-type 'symbol=? args))))

   ;; Booleans
   (set! not (proc-one 'not proc-true
                       (lambda (obj)
                         (if (eq? obj #f) #t #f))))
   (set! boolean? (proc-one 'boolean? proc-true c-boolean?))
   (set! boolean=?
         (lambda args
           (length-> 'boolean=? args 2)
           ((lambda ()
              (define (iter b rest)
                (if (null? rest)
                    #t
                    ((lambda (b0)
                       (if (boolean? b0)
                           (if (eqv? b b0)
                               (iter b0 (cdr rest))
                               #f)
                           (error-type 'boolean=? args)))
                     (car rest))))
              ((lambda (b)
                 (if (boolean? b)
                     (iter b (cdr args))
                     (error-type 'boolean=? args)))
               (car args))))))

   ;; Pairs and lists
   (set! pair? (proc-one 'pair? proc-true c-pair?))   
   (set! cons (lambda args (length-= 'cons args 2)
                      ((lambda (o1 o2)
                         (c-cons o1 o2))
                       (car args) (cadr args))))
   
   (set! car (proc-one 'car pair? c-car))
   (set! cdr (proc-one 'cdr pair? c-cdr))
   (set! set-car! (proc-set-cr! 'set-car! c-set-car!))
   (set! set-cdr! (proc-set-cr! 'set-cdr! c-set-cdr!))
   
   ;; Characters
   (set! char? (proc-one 'char? proc-true c-char?))
   (set! char=? (char-cmp 'char=? = id))
   (set! char<? (char-cmp 'char=? < id))
   (set! char>? (char-cmp 'char=? > id))
   (set! char<=? (char-cmp 'char=? <= id))
   (set! char>=? (char-cmp 'char=? >= id))
   (set! char-ci=? (char-cmp 'char=? = char-foldcase))
   (set! char-ci<? (char-cmp 'char=? < char-foldcase))
   (set! char-ci>? (char-cmp 'char=? > char-foldcase))
   (set! char-ci<=? (char-cmp 'char=? <= char-foldcase))
   (set! char-ci>=? (char-cmp 'char=? >= char-foldcase))
   
   (set! char-alphabetic? (char-proc 'char-alphabetic? c-char-alphabetic?))
   (set! char-numeric? (char-proc 'char-numeric? c-char-numeric?))
   (set! char-whitespace? (char-proc 'char-whitespace? c-char-whitespace?))
   (set! char-upper-case? (char-proc 'char-upper-case? c-char-upper-case?))
   (set! char-lower-case? (char-proc 'char-lower-case? c-char-lower-case?))
   (set! digit-value (char-proc 'digit-value c-digit-value))
   (set! char->integer (char-proc 'char->integer c-char->integer))
   (set! integer->char
         (lambda args
           (length-= 'integer->char args 1)
           ((lambda (n)
              (if (and (integer? n)
                       (<= 0 n) (<= n #x10ffff))
                  (c-integer->char n)
                  (error-type 'integer->char args)))
            (car args))))
   (set! char-upcase (char-proc 'char c-char-upcase))
   (set! char-downcase (char-proc 'char c-char-downcase))
   (set! char-foldcase (char-proc 'char c-char-foldcase))

   (set! string? (proc-one 'string? proc-true c-string?))
   (set! make-string
         (lambda args
           ((lambda (len)
              (if (or (= len 1) (= len 2))
                  ((lambda ()
                     (define k (car args))
                     (define char (if (= len 1) #\space (cadr args)))
                     (if (and (>= k 0) (char? char))
                         (c-make-string k char)
                         (error-type 'namek-string args))))
                  (error-args 'make-string args)))
            (length args))))
   (set! string-length
         (lambda args
           (length-= 'string-length args 1)
           ((lambda (s)
              (if (string? s)
                  (c-string-length s)
                  (error-type 'string-length args)))
            (car args))))
   (set! string-ref
         (lambda args
           (length-= 'string-ref args 2)
           ((lambda (s k)
              (if (and (string? s) (integer? k) (exact? k) (<= 0 k)
                       (< k (string-length s)))
                  (c-string-ref s k)
                  (error-type 'string-ref args)))
            (car args) (cadr args))))
   (set! string-set!
         (lambda args
           (length-= 'string-set! args 3)
           ((lambda (s k c)
              (if (and (string? s) (integer? k) (exact? k) (<= 0 k)
                       (< k (string-length s)) (char? c))
                  (c-string-set! s k char)
                  (error-type 'string-set! args)))
            (car args) (cadr args) (caddr args))))
   
   (set! string=? (string-cmp 'string=? char=?))
   (set! string-ci=? (string-cmp 'string-ci=? char-ci=?))
   (set! string<? (string-cmp 'string<? char<?))
   (set! string-ci<? (string-cmp 'string-ci<? char-ci<?))
   (set! string>? (string-cmp 'string>? char>?))
   (set! string-ci>? (string-cmp 'string-ci>? char-ci>?))
   (set! string<=? (string-cmp 'string<=? char<=?))
   (set! string-ci<=? (string-cmp 'string-ci<=? char-ci<=?))
   (set! string>=? (string-cmp 'string>=? char>=?))
   (set! string-ci>=? (string-cmp 'string-ci>=? char-ci>=?))

   ;; Control features
   (set! procedure? (proc-one 'procedure? proc-true c-procedure?))

   ;; 6.11 Exceptions
   (set! error (proc-one 'error proc-true c-error))
   ;; Input and output
   (set! input-port? (proc-one 'input-port? proc-true c-input-port?))
   (set! output-port? (proc-one 'output-port? proc-true c-output-port?))
   (set! textual-port? (proc-one 'textual-port? proc-true c-textual-port?))
   (set! binary-port? (proc-one 'output-port? proc-true c-output-port?))
   (set! open-input-file (proc-one 'open-input-file string? c-open-input-file))
   (set! open-binary-input-file
         (proc-one 'open-binary-input-file string? c-open-binary-input-file))
   (set! open-output-file
         (proc-one 'open-output-file string? c-open-output-file))
   (set! open-binary-output-file
         (proc-one 'open-binary-output-file string? c-open-binary-output-file))
   (set! close-port (proc-one 'close-port port? c-close-port))
   (set! read
         (lambda args
           ((lambda (len)
              (if (and (< len 1) (< 2 len))
                  (error-args 'read args)
                  (if (= len 1)
                      (c-read (current-input-port))
                      ((lambda (obj)
                         (if (and (input-port? obj) (text-port? obj))
                             (c-read obj)
                             (error-type 'read args)))
                       (car args)))))
            (length args))))
   (set! write
         (lambda args
           ((lambda (len)
              (if (and (< len 1) (< 2 len))
                  (error-args 'write args)
                  (if (= len 1)
                      (c-write (car args) (current-output-port))
                      ((lambda (obj)
                         (if (and (output-port? obj) (text-port? obj))
                             (c-write (car args) obj)
                             (error-type 'write args)))
                       (cadr args)))))
            (length args))))
   )
 ;; arguments
 ;; Equivalence predicates
 eqv? eq?
 ;; Numbers
 complex? exact? finite? infinite? nan? + * - / gcd lcm numerator denominator
 floor ceiling truncate round exp log sin cos tan asin acos atan sqrt
 real-part imag-part exact
 number->string string->number
 ;; Booleans
 boolean?
 ;; Pairs and lists
 pair? cons car cdr set-car! set-cdr!
 ;; Symbols
 symbol=?
 ;; Characters
 char? char-alphabetic? char-numeric? char-whitespace?
 char-upper-case? char-lower-case? digit-value
 char->integer integer->char char-upcase char-downcase
 char-foldcase
 ;; Strings
 string? make-string string-length string-ref string-set!

 ;; Control features
 procedure?
 ;; Exceptions
 error
 ;; Input and output
 input-port? output-port? textual-port? binary-port?
 open-input-file open-binary-input-file open-output-file open-binary-output-file
 close-port
 read
 write)

(define (equal? obj1 obj2)
  (if (and (pair? obj1) (pair? obj2))
      (and (equal? (car obj1) (car obj2)) (equal? (cdr obj1) (cdr obj2)))
      (if (and (vector? obj1) (vector? obj2))
          (equal? (vector->list obj1) (vector->list obj2))
          (if (and (string? obj1) (string? obj2))
              (equal? (string->list obj1) (string->list obj2))
              (if (and (bytevector? obj1) (bytevector? obj2))
                  (equal? (bytevector-utf8 obj1) (bytevector-utf8 obj2))
                  (if (or (boolean? obj1)
                          (symbol? obj1)
                          (number? obj1)
                          (char? obj1)
                          (port? obj1)
                          (procedure? obj1)
                          (null? obj1))
                      (eqv? obj1 obj2)
                      #f))))))
;; Numbers
(define complex? number?)
(define (real? obj)(and (complex? obj) (= (imag-part obj) 0)))
(define (rational? obj) (and (real? obj) (= obj (exact obj))))
(define (integer? obj) (and (real? obj) (= obj (round obj))))
(define (inexact? obj) (if (complex? obj)
                           (not (exact? obj))
                           (error "wrong type argument -- inexact?" obj)))
(define (= z1 z2 . rest)
  (define (iter a b rest)
    (if (and (complex? a) (complex? b))
        (if (zero? (- a b))
            (if (null? rest)
                #t
                (iter b (car rest) (cdr rest)))
            #f)
        (error "wrong type argument -- =" (list z1 z2 rest))))
  (iter z1 z2 rest))
(define (< z1 z2 . rest)
  (define (iter a b rest)
    (if (and (real? a) (real? b))
        (if (negative? (- a b))
            (if (null? rest)
                #t
                (iter b (car rest) (cdr rest)))
            #f)
        (error "wrong type argument -- <" (list z1 z2 rest))))
  (iter z1 z2 rest))
(define (> z1 z2 . rest)
  (define (iter a b rest)
    (if (and (real? a) (real? b))
        (if (positive? (- a b))
            (if (null? rest)
                #t
                (iter b (car rest) (cdr rest)))
            #f)
        (error "wrong type argument -- >" (list z1 z2 rest))))
  (iter z1 z2 rest))
(define (<= z1 z2 . rest)
  (define (iter a b rest)
    (if (and (real? a) (real? b))
        (if (negative? (- a b))
            #f
            (if (null? rest)
                #t
                (iter b (car rest) (cdr rest))))
        (error "wrong type argument -- <=" (list z1 z2 rest))))
  (iter z1 z2 rest))
(define (<= z1 z2 . rest)
  (define (iter a b rest)
    (if (and (real? a) (real? b))
        (if (positive? (- a b))
            #f
            (if (null? rest)
                #t
                (iter b (car rest) (cdr rest))))
        (error "wrong type argument -- <=" (list z1 z2 rest))))
  (iter z1 z2 rest))
(define (zero? z) (if (complex? z)
                      (= z 0)
                      (error "wrong type argument -- zero?" z)))
(define (positive? z) (if (real? z)
                          (> z 0)
                          (error "wrong type argument -- positive?" z)))
(define (negative? z) (if (real? z)
                          (< z 0)
                          (error "wrong type argument -- negative?" z)))
(define (odd? n)
  (if (integer? n)
      (= (remainder n 2) 0)
      (error "wrong type argument -- odd?" n)))
(define (even? n)
  (if (integer? n)
      (= (remainder n 2) 1)
      (error "wrong type argument -- odd?" n)))
(define (max x . rest)
  (define (iter x rest)
    (if (null? rest)
        x
        ((lambda (y)
           (if (real? y)
               (iter (if (< x y) y x) (cdr rest))
               (error "Wrong type argument -- max" y)))
         (car rest))))
  (if (real? x)
      (iter x rest)
      (error "Wrong type argument -- max" y)))
(define (min x . rest)
  (define (iter x rest)
    (if (null? rest)
        x
        ((lambda (y)
           (if (real? y)
               (iter (if (> x y) y x) (cdr rest))
               (error "Wrong type argument -- max" y)))
         (car rest))))
  (if (real? x)
      (iter x rest)
      (error "Wrong type argument -- min" y)))
(define (abs z)
  (if (real? z)
      (if (positive? z)
          z
          (- z))
      (error "wrong type argument -- abs" z)))
(define (floor-quotient n1 n2)
  (if (and (integer? n1) (integer? n2))
      (floor (/ n1 n2))
      (error "Wrong type argument -- floor-quotient" n1 n2)))
(define (floor-remainder n1 n2)
  (if (and (integer? n1) (integer? n2))
      (- n1 (* n2 (floor-quotient n1 n2)))
      (error "Wrong type argument -- floor-remainder" n1 n2)))
(define (truncate-quotient n1 n2)
  (if (and (integer? n1) (integer? n2))
      (truncate (/ n1 n2))
      (error "Wrong type argument -- truncate-quotient" n1 n2)))
(define (truncate-remainder n1 n2)
  (if (and (integer? n1) (integer? n2))
      (- n1 (* n2 (floor-quotient n1 n2)))
      (error "Wrong type argument -- truncate-remainder" n1 n2)))
(define quotient truncate-quotient)
(define remainder truncate-remainder)
(define module floor-remainder)
(define (rationalize x y)
  (define sgn (if (negative? x)
                  (lambda (x) (- x))
                  (lambda (x) x)))
  (define e (if (and (exact? x) (exact? y))
                exact
                inexact))
  (define (proc q) (sgn (e q)))
  (define x0 (abs x))
  (define y0 (abs y))
  (define low (- x0 y0))
  (define high (+ x0 y0))
  (proc 
   (if (positive? (* low high))
       ((lambda ()
          (define (between? q) (and (<= low q)
                                    (<= q high)))
          (define (iter n0 d0 n1 d1 n2 d2)
            ((lambda (q)
               (if (between? q)
                   q
                   (if (< q low)
                       (iter n1 d1
                             (+ n1 n2) (+ d1 d2)
                             n2 d2)
                       (iter n0 d0
                             (+ n0 n1) (+ d0 d1)
                             n1 d1))))
             (/ n1 d1)))
          (iter 0 1 1 1 1 0)))
       0)))
(define (square z) (* z z))
(define (exact-integer? z) (and (integer? z) (exact? z)))
;; Pairs and lists
(define (caar pair) (car (car pair)))
(define (cadr pair) (car (cdr pair)))
(define (cdar pair) (cdr (car pair)))
(define (cddr pair) (cdr (cdr pair)))
(define (caaar pair) (car (car (car pair))))
(define (caadr pair) (car (car (cdr pair))))
(define (cadar pair) (car (cdr (car pair))))
(define (caddr pair) (car (cdr (cdr pair))))
(define (cdaar pair) (cdr (car (car pair))))
(define (cdadr pair) (cdr (car (cdr pair))))
(define (cddar pair) (cdr (cdr (car pair))))
(define (cdddr pair) (cdr (cdr (cdr pair))))
(define (caaaar pair) (car (car (car (car pair)))))
(define (caaadr pair) (car (car (car (cdr pair)))))
(define (caadar pair) (car (car (cdr (car pair)))))
(define (caaddr pair) (car (car (cdr (cdr pair)))))
(define (cadaar pair) (car (cdr (car (car pair)))))
(define (cadadr pair) (car (cdr (car (cdr pair)))))
(define (caddar pair) (car (cdr (cdr (car pair)))))
(define (cadddr pair) (car (cdr (cdr (cdr pair)))))
(define (cdaaar pair) (cdr (car (car (car pair)))))
(define (cdaadr pair) (cdr (car (car (cdr pair)))))
(define (cdadar pair) (cdr (car (cdr (car pair)))))
(define (cdaddr pair) (cdr (car (cdr (cdr pair)))))
(define (cddaar pair) (cdr (cdr (car (car pair)))))
(define (cddadr pair) (cdr (cdr (car (cdr pair)))))
(define (cdddar pair) (cdr (cdr (cdr (car pair)))))
(define (cddddr pair) (cdr (cdr (cdr (cdr pair)))))
(define (null? obj) (eqv? obj '()))
(define (list? obj)
  (if (null? obj)
      #t
      (if (pair? obj)
          (list? (cdr obj))
          #f)))
(define (make-list k . rest)
  (define fill (if (null? rest) '() (car rest)))
  (define (iter n result)
    (if (= n k)
        result
        (iter (+ n 1) (cons fill result))))
  (iter 0 '()))
(define (list . args) args)
(define (length list)
  (define (iter list result)
    (if (null? list)
        result
        (iter (cdr list) (+ result 1))))
  (iter list 0))
(define (append . list-of-list)
  (if (null? list-of-list)
      '()
      ((lambda (reversed)
         ((lambda (o)
            (if (or (null? o) (pair? o))
                ((lambda ()
                   (define (iter1 list result)
                     (if (null? list)
                         result
                         (iter1 (cdr list) (cons (car list) result))))
                   (define (iter2 list-of-list result)
                     (if (null? list-of-list)
                         result
                         (iter2 (cdr list-of-list)
                                (iter1 (reverse (car list-of-list)) result))))
                   (iter2 (cdr reversed) o)))
                o))
          (car reversed)))
       (reverse list-of-list))))
(define (reverse list)
  (define (iter list result)
    (if (null? list)
        result
        (iter (cdr list) (cons (car list) result))))
  (iter list '()))
(define (list-tail list k)
  (if (zero? k)
      list
      (list-tail (cdr list) (- k 1))))
(define (list-ref list k)
  (if (zero? k)
      (car list)
      (list-ref (cdr list) (- k 1))))
(define (list-set! list k obj)
  (if (zero? k)
      (set-car! list obj)
      (list-set! (cdr list) (- k 1) obj)))
(define (memq obj list)
  (if (null? list)
      #f
      (if (eq? obj (car list) )
          list
          (memq obj (cdr list)))))
(define (memv obj list)
  (if (null? list)
      #f
      (if (eqv? obj (car list) )
          list
          (memv obj (cdr list)))))
(define (member obj list . rest)
  (define compare (if (null? rest) equal? (car rest)))
  (define (iter list)
    (if (null? list)
        #f
        (if (compare obj (car list))
            list
            (iter (cdr list)))))
  (iter list))
(define (assq obj alist)
  (if (null? alist)
      #f
      ((lambda (pair)
         (if (eq? obj (car pair))
             pair
             (assq obj (cdr alist))))
       (car alist))))
(define (assv obj alist)
  (if (null? alist)
      #f
      ((lambda (pair)
         (if (eqv? obj (car pair))
             pair
             (assv obj (cdr alist))))
       (car alist))))
(define (assoc obj alist . rest)
  (define compare (if (null? rest) equal? (car rest)))
  (define (iter alist)
    (if (null? alist)
        #f
        ((lambda (pair)
           (if (compare (obj (car pair)))
               pair
               (iter (cdr alist))))
         (car alist))))
  (iter alist))

(define (list-copy obj)
  (define (iter obj)
    (if (pair? obj)
        (cons (car obj) (iter (cdr ob)))
        obj))
  (iter obj))

;; Strings
(define (string . rest)
  (define k (length rest))
  (define s (make-string k))
  (define (iter k0 chars)
    (if (= k0 k)
        s
        ((lambda ()
           (string-set! s k0 (car chars))
           (iter (+ k0 1) (cdr chars))))))
  (iter 0 rest))

(define (string-upcase string) (string-map char-upcase string))
(define (string-downcase string) (string-map char-downcase string))
(define (string-foldcase string) (string-map char-foldcase string))

(define (substring string start end) (string-copy string start end))

(define (string-append . list-of-string)
  (list->string (apply append (map string->list list-of-string))))

(define (string->list string . rest)
  (define start (if (null? rest) 0 (car rest)))
  (define end (if (or (null? rest) (null? (cdr rest)))
                  (string-length string)
                  (cadr rest)))
  (define (iter i result)
    (if (< i start)
        result
        (iter (+ i 1) (cons (string-ref string i) result))))
  (iter (- end 1) '()))

(define (string->copy string . rest)
  (define start (if (null? rest) 0 (car rest)))
  (define end (if (or (null? rest) (null? (cdr rest)))
                  (string-length s)
                  (cadr rest)))
  (define s (make-string (- end start)))
  (define (iter i)
    (if (= i end)
        s
        ((lambda ()
           (string-set! s i (string-ref string i))
           (iter (+ i 1))))))
  (iter start))

(define (string-copy! to at from . rest)
  (define start (if (null? rest) 0 (car rest)))
  (define end (if (or (null? rest) (null? (cdr rest)))
                  (string-length s)
                  (cadr rest)))
  (define (iter i j)
    (if (< j end)
        ((lambda ()
           (string-set! to i (string-ref from j))
           (iter (+ i 1) (+ j 1))))))
  (iter at start))

(define (string-fill! string fill . rest)
  (define start (if (null? rest) 0 (car rest)))
  (define end (if (or (null? rest) (null? (cdr rest)))
                  (cadr rest)
                  (string-length string)))
  (define (iter i)
    (if (= end i)
        string
        ((lambda ()
           (string-set! string i fill)
           (iter (+ i 1))))))
  (iter start))

;; Vectors

;; Control features
(define (map proc list1 . list-of-list)
  (if (null? list-of-list)
      ((lambda ()
         (define (iter list result)
           (if (null? list)
               (reverse result)
               (iter (cdr list) (cons (proc (car list)) result))))
         (iter list1 '())))
      ((lambda ()
         (define (iter list-of-list result)
           (if (memv '() list-of-list)
               (reverse result)
               (iter (cdrs list-of-list)
                     (cons (apply proc (cars list-of-list)) result))))
         (define (cars list-of-list)
           (define (iter list-of-list result)
             (if (null? list-of-list)
                 (reverse result)
                 (iter (cdr list-of-list) (cons (caar list-of-list) result))))
           (iter list-of-list '()))
         (define (cdrs list-of-list)
           (define (iter list-of-list result)
             (if (null? list-of-list)
                 (reverse result)
                 (iter (cdr list-of-list)
                       (cons (cdar list-of-list) result))))
           (iter list-of-list '()))
         (iter (cons list1 list-of-list) '())))))

(define (string-map proc string1 . list-of-string)
  (list->string
   (apply map (cons proc (map string->list (cons string1 list-of-string))))))
(define (vector-mp proc vector1 . list-of-vector)
  (list->vector
   (apply map (cons proc (map vector->list (cons vector1 list-of-vector))))))
(define (for-each proc list1 . list-of-list)
  (if (null? list-of-list)
      ((lambda ()
         (define (iter list)
           (if (not (null? list))
               ((lambda ()
                  (proc (car list))
                  (iter (cdr list))))))
         (iter list1)))
      ((lambda ()
         (define (iter list-of-list)
           (if (not (memv '() list-of-list))
               ((lambda ()
                  (apply proc (cars list-of-list))
                  (iter (cdrs list-of-list))))))
         (define (cars list-of-list)
           (define (iter list-of-list result)
             (if (null? list-of-list)
                 (reverse result)
                 (iter (cdr list-of-list) (cons (caar list-of-list) result))))
           (iter list-of-list '()))
         (define (cdrs list-of-list)
           (define (iter list-of-list result)
             (if (null? list-of-list)
                 (reverse result)
                 (iter (cdr list-of-list)
                       (cons (cdar list-of-list) result))))
           (iter list-of-list '()))
         (iter (cons list1 list-of-list))))))
(define (string-for-each proc string1 . list-of-string)
  (apply for-each (cons proc (map string->list (cons string1 list-of-string)))))
(define (vector-for-each proc vector1 . list-of-vector)
  (apply for-each (cons proc (map vector->list (cons vector1 list-of-vector)))))

;; Input and output
(define (port? obj) (or (input-port? obj) (output-port? obj)))
(define (close-input-port port)
  (if (input-port? port)
      (close-port port)
      (error "Wrong type argument -- close-input-port" port)))
(define (close-output-port port)
  (if (output-port? port)
      (close-port port)
      (error "Wrong type argument -- close-output-port" port)))

