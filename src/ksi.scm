(begin
  (define (error message . objs)
    (list 'error-object message objs))
  (define (error-object? exp)
    (tagged-list? exp 'error-object))
  (define (error-object-message exp) (car (cdr exp)))
  (define (error-irritants exp) (car (cdr (cdr exp))))
  
  (define (eval exp env)
    (if (error-object? exp)
        exp
        (if
         (eof-object? exp)
         (exit)
         (if
          (self-evaluating? exp)
          exp
          (if
           (variable? exp)
           (lookup-variable-value exp env)
           (if
            (quoted? exp)
            (text-of-quotation exp)
            (if
             (lambda? exp)
             (make-procedure (lambda-parameters exp)
                             (lambda-body exp)
                             env)
             (if
              (definition? exp)
              (eval-definition exp env)
              (if
               (assignment? exp)
               (eval-assignment exp env)
               (if
                (if? exp)
                (eval-if exp env)
                (if
                 (begin? exp)
                 (eval-sequence (begin-actions exp) env)
                 (if (and? exp)
                     (eval (and->if exp) env)
                     (if (or? exp)
                         (eval (or->if exp) env)
                         (if
                          (load? exp)
                          (eval (read (open-input-file (car (cdr exp)))) env)
                          (if
                           (pair? exp)
                           (begin
                             (define op (eval (car exp) env))
                             (if (error-object? op)
                                 op
                                 (begin
                                   (define ops (list-of-values (cdr exp) env))
                                   (define o (include-error? ops))
                                   (if o
                                       o
                                       (apply op ops)))))
                           (error "(eval) unknown expression type --"
                                  exp))))))))))))))))

  (define (eval-definition exp env)
    (if (or (and (c-symbol? (car (cdr  exp)))
                 (= (length exp) 3))
            (and (pair? (car (cdr  exp)))
                 (< 2 (length exp))))
        (begin
          (define o (eval (definition-value exp) env))
          (if (error-object? o)
              o
              (define-variable!
                (definition-variable exp)
                o
                env)
              (error "(eval) unknown expression type --" exp)))))

  (define (eval-assignment exp env)
    (if (= (length exp) 3)
        (begin
          (define o (eval (assignment-value exp) env))
          (if (error-object? o)
              o
              (set-variable-value! (assignment-variable exp)
                                   o
                                   env)))
        (error "(eval) unknown expression type --" exp)))

  (define (eval-if exp env)
    (if (or (= (length exp) 3)
            (= (length exp) 4))
        (begin
          (define pred (eval (if-predicate exp) env))
          (if (error-object? pred)
              pred
              (if pred
                  (eval (if-consequent exp) env)
                  (eval (if-alternative exp) env))))
        (error "(eval) unknown expression type --" exp)))

  (define (eval-sequence exps env)
    (if (c-null? (cdr  exps))
        (eval (car exps) env)
        (begin
          (define o (eval (car exps) env))
          (if (error-object? o)
              o
              (eval-sequence (cdr exps) env)))))

  (define (include-error? list)
    (if (c-null? list)
        #f
        (if (error-object? (car list))
            (car list)
            (include-error? (cdr list)))))
  (define (list-of-values exps env)
    (if (c-null? exps)
        '()
        (c-cons (eval (car exps) env)
                (list-of-values (cdr exps) env))))
  
  (define (apply procedure arguments)
    (if (primitive-procedure? procedure)
        (c-apply (primitive-implementation procedure) arguments)
        (if (compound-procedure? procedure)
            (begin
              (define env  (extend-environment
                            (procedure-parameters procedure)
                            arguments
                            (procedure-environment procedure)))
              (if (error-object? env)
                  env
                  (eval-sequence (procedure-body procedure) env)))
            (error "unknown procedure type --" procedure))))
  
  (define (self-evaluating? exp)
    (or (boolean? exp)
        (number? exp)
        (vector? exp)
        (c-char? exp)
        (string? exp)
        (bytevector? exp)
        (procedure? exp)
        (eq? exp (if #f #f))))
  (define (variable? exp) (c-symbol? exp))
  (define (quoted? exp) (tagged-list? exp 'quote))
  (define (text-of-quotation exp) (car (cdr exp)))
  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        #f))
  
  (define (lambda? exp) (tagged-list? exp 'lambda))
  (define (lambda-parameters exp) (car (cdr exp)))
  (define (lambda-body exp) (cdr (cdr exp)))
  (define (make-lambda parameters body) (c-cons 'lambda (c-cons parameters body)))

  (define (if? exp) (tagged-list? exp 'if))
  (define (if-predicate exp) (car (cdr exp)))
  (define (if-consequent exp) (car (cdr (cdr exp))))
  (define (if-alternative exp)
    (if (not (c-null? (cdr (cdr (cdr exp)))))
        (car (cdr (cdr (cdr exp))))))

  (define (begin? exp) (tagged-list? exp 'begin))
  (define (begin-actions exp) (cdr exp))

  (define (and? exp) (tagged-list? exp 'and))
  (define (and->if exp)
    (if (c-null? exp)
        #t
        (begin          
          (define (iter o)
            (if (c-null? (cdr o))
                (car o)
                (list 'if
                      (car o)
                      (iter (cdr o))
                      '#f)))
          (iter exp))))
  
  (define (or? exp) (tagged-list? exp 'or))
  (define (or->if exp)
    (if (c-null? exp)
        '#f
        (list 'if (car exp) (car exp) (c-cons 'or (cdr exp)))))
  
  (define (load? exp) (tagged-list? exp 'load))
  
  (define (definition? exp) (tagged-list? exp 'define))
  (define (definition-variable exp)
    (if (c-symbol? (car (cdr exp)))
        (car (cdr exp))
        (car (car (cdr exp)))))
  (define (definition-value exp)
    (if (c-symbol? (car (cdr exp)))
        (car (cdr (cdr exp)))
        (make-lambda (cdr (car (cdr exp)))
                     (cdr (cdr exp)))))
  (define (assignment? exp) (tagged-list? exp 'set!))
  (define (assignment-variable exp) (car (cdr exp)))
  (define (assignment-value exp) (car (cdr (cdr exp))))
  (define (first-frame env) (car env))
  (define the-empty-environment '())
  (define (make-frame variables values) (c-cons variables values))
  (define (frame-variables frame) (car frame))
  (define (frame-values frame) (cdr frame))
  (define (add-binding-to-frame! var val frame)
    (set-car! frame (c-cons var (car frame)))
    (set-cdr! frame (c-cons val (cdr frame))))   
  (define (define-variable! var val env)
    ((lambda (frame)
       (define (scan vars vals)
         (if (c-null? vars)
             (add-binding-to-frame! var val frame)
             (if (eq? var (car vars))
                 (set-car! vals val)
                 (scan (cdr vars) (cdr vals)))))
       (scan (frame-variables frame)
             (frame-values frame)))
     (first-frame env)))
  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan vars vals)
        (if (c-null? vars)
            (env-loop (enclosing-environment env))
            (if (eq? var (car vars))
                (set-car! vals val)
                (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "(set!) unbound variable --" var)
          ((lambda (frame)
             (scan (frame-variables frame)
                   (frame-values frame)))
           (first-frame env))))
    (env-loop env))
  
  (define (make-procedure parameters body env)
    (list 'procedure parameters body env))
  (define (compound-procedure? p) (tagged-list? p 'procedure))
  (define (procedure-parameters p) (car (cdr p)))
  (define (procedure-body p) (car (cdr (cdr p))))
  (define (procedure-environment p) (car (cdr (cdr (cdr p)))))
  
  (define (enclosing-environment env) (cdr env))
  (define (extend-environment vars vals base-env)
    (define (iter vars-0 vals-0 vars-1 vals-1)
      (if (c-symbol? vars-0)
          (c-cons (make-frame (c-cons vars-0 vars-1)
                              (c-cons vals-0 vals-1))
                  base-env)
          (if (c-null? vars-0)
              (if (c-null? vals-0)
                  (c-cons (make-frame vars-1 vals-1) base-env)
                  (error "too many arguments supplied" vars vals))
              (if (c-null? vals-0)
                  (error "too few arguments supplied" vars vals)
                  (iter (cdr vars-0)
                        (cdr vals-0)
                        (c-cons (car vars-0) vars-1)
                        (c-cons (car vals-0) vals-1))))))
    (iter vars vals '() '()))
  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (if (c-null? vars)
            (env-loop (enclosing-environment env))
            (if (eq? var (car vars))
                (car vals)
                (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "unbound variable --" var)
          ((lambda (frame)
             (scan (frame-variables frame)
                   (frame-values frame)))
           (first-frame env))))
    (env-loop env))

  (define (numbers? objs)
    (if (c-null? objs)
        #t
        (if (number? (car objs))
            (numbers? (cdr objs))
            #f)))

  (define (primitive-procedure? proc) (tagged-list? proc 'primitive))
  (define (primitive-implementation proc) (car (cdr proc)))
  (load "./lib/stdlib/base/primitive_procedures.scm")
  (load "./lib/stdlib/char/primitive_procedures.scm")
  (load "./lib/stdlib/complex/primitive_procedures.scm")
  (define primitive-procedures
    (list (c-cons '* *)
          (c-cons '+ +)
          (c-cons '- -)
          (c-cons '/ /)
          (c-cons '< <)
          (c-cons '<= <=)
          (c-cons '= =)
          (c-cons '> >)
          (c-cons '>= >=)
          (c-cons 'abs abs)
          (c-cons 'append append)
          (c-cons 'binary-port? binary-port?)
          (c-cons 'boolean=? boolean=?)
          (c-cons 'boolean? boolean?)          
          (c-cons 'bytevector bytevector)
          (c-cons 'bytevector-append bytevector-append)
          (c-cons 'bytevector-copy bytevector-copy)
          (c-cons 'bytevector-length bytevector-length)
          (c-cons 'bytevector-u8-ref bytevector-u8-ref)
          (c-cons 'bytevector-u8-set! bytevector-u8-set!)
          (c-cons 'bytevector? bytevector?)
          (c-cons 'car car)
          (c-cons 'cdr cdr)
          (c-cons 'ceiling ceiling)
          (c-cons 'char->integer char->integer)
          (c-cons 'char<=? char<=?)           
          (c-cons 'char<? char<?)
          (c-cons 'char=? char=?)
          (c-cons 'char>=? char>=?)
          (c-cons 'char>? char>?)
          (c-cons 'char? char?)           
          (c-cons 'close-input-port close-input-port)
          (c-cons 'close-output-port close-output-port)
          (c-cons 'close-port close-port)
          (c-cons 'complex? complex?)
          (c-cons 'cons cons)
          (c-cons 'current-error-port current-error-port)
          (c-cons 'current-input-port current-input-port)
          (c-cons 'current-output-port current-output-port)
          (c-cons 'denominator denominator)
          (c-cons 'eof-object eof-object)
          (c-cons 'eof-object? eof-object?)
          (c-cons 'eq? eq?)
          (c-cons 'eqv? eqv?)
          (c-cons 'error (lambda args
                           (if (c-null? args)
                               (error '|(error) wrong number of arguments --| args)
                               (c-apply error args))))
          (c-cons 'error-object-irritants
                  (lambda args
                    (if (c-= (c-length args) 1)
                        (if (error-object? (c-car args))
                            (error-object-irritants (c-car args))
                            (error
                             '|(error-object-irritants) wrong type of argument --|
                             args))
                        (error
                         '|(error-object-irritants) wrong number of arguments --|
                         args))))
          (c-cons 'error-object-message
                  (lambda args
                    (if (c-= (c-length args) 1)
                        (if (error-object? (c-car args))
                            (error-object-message (c-car args))
                            (error
                             '|(error-object-message) wrong type of argument --|
                             args))
                        (error
                         '|(error-object-message) wrong number of arguments --|
                         args))))
          (c-cons 'error-object?
                  (lambda args
                    (if (c-= (c-length args) 1)
                        (error-object? (c-car args))
                        (error
                         '|(error-object?) wrong number of arguments --| args))))
          (c-cons 'even? even?)
          (c-cons 'exact exact)
          (c-cons 'exact? exact?)
          (c-cons 'expt expt)
          (c-cons 'floor floor)
          (c-cons 'flush-output-port flush-output-port)
          (c-cons 'gcd gcd)
          (c-cons 'inexact inexact)
          (c-cons 'input-port-open? input-port-open?)
          (c-cons 'input-port? input-port?)
          (c-cons 'integer->char integer->char)
          (c-cons 'integer? integer?)
          (c-cons 'lcm lcm)
          (c-cons 'length length)
          (c-cons 'list list)           
          (c-cons 'list->string list->string)
          (c-cons 'list? list?)
          (c-cons 'make-bytevector make-bytevector)
          (c-cons 'make-list make-list)
          (c-cons 'make-string make-string)
          (c-cons 'negative? negative?)
          (c-cons 'newline newline)
          (c-cons 'null? null?)
          (c-cons 'number? number?)
          (c-cons 'numerator numerator)
          (c-cons 'odd? odd?)
          (c-cons 'output-port-open? output-port-open?)
          (c-cons 'output-port? output-port?)
          (c-cons 'pair? pair?)
          (c-cons 'port? port?)
          (c-cons 'positive? positive?)
          (c-cons 'procedure?
                  (lambda args
                    (if (c-= (c-length args) 1)
                        (or (primitive-procedure? (c-car args))
                            (compound-procedure? (c-car args)))
                        (error
                         '|(procedure?) wrong number of arguments --| args))))
          (c-cons 'raise
                  (lambda args
                    (if (c-= (c-length args) 1)
                        (error '|| (c-car args))
                        (error
                         '|(raise) wrong number of arguments --| args))))
          (c-cons 'rational? rational?)
          (c-cons 'read-bytevector read-bytevector)
          (c-cons 'read-char read-char)
          (c-cons 'read-u8 read-u8)
          (c-cons 'real? real?)
          (c-cons 'reverse reverse)
          (c-cons 'round round)
          (c-cons 'set-car! set-car!)
          (c-cons 'set-cdr! set-cdr!)
          (c-cons 'square square)
          (c-cons 'string->list string->list)
          (c-cons 'string->number string->number)
          (c-cons 'string->symbol string->symbol)
          (c-cons 'string->utf8 string->utf8)
          (c-cons 'string-length string-length)
          (c-cons 'string-ref string-ref)
          (c-cons 'string-set! string-set!)
          (c-cons 'string<=? string<=?)
          (c-cons 'string<? string<?)
          (c-cons 'string=? string=?)
          (c-cons 'string>=? string>=?)
          (c-cons 'string>? string>?)
          (c-cons 'string? string?)
          (c-cons 'symbol->string symbol->string)
          (c-cons 'symbol=? symbol=?)
          (c-cons 'textual-port? textual-port?)
          (c-cons 'truncate truncate)
          (c-cons 'utf8->string utf8->string)
          (c-cons 'vector? vector?)
          (c-cons 'write-bytevector write-bytevector)
          (c-cons 'write-char write-char)
          (c-cons 'write-string write-string)
          (c-cons 'write-u8 write-u8)

          ;; char
          (c-cons 'char-alphabetic? char-alphabetic?)
          (c-cons 'char-ci<=? char-ci<=?)
          (c-cons 'char-ci<? char-ci<?)
          (c-cons 'char-ci=? char-ci=?)
          (c-cons 'char-ci>=? char-ci>=?)
          (c-cons 'char-ci>? char-ci>?)
          (c-cons 'char-downcase char-downcase)
          (c-cons 'char-foldcase char-foldcase)
          (c-cons 'char-lower-case? char-lower-case?)
          (c-cons 'char-numeric? char-numeric?)
          (c-cons 'char-upcase char-upcase)
          (c-cons 'char-upper-case? char-upper-case?)
          (c-cons 'char-whitespace? char-whitespace?)
          (c-cons 'digit-value digit-value)

          ;; complex
          (c-cons 'angle angle)
          (c-cons 'imag-part imag-part)
          (c-cons 'magnitude magnitude)
          (c-cons 'make-polar make-polar)
          (c-cons 'make-rectangular make-rectangular)
          (c-cons 'real-part real-part)
          ))
  (define (map proc list)
    (if (c-null? list)
        '()
        (c-cons (proc (car list))
                (map proc (cdr list)))))
  (define (primitive-procedure-names) (map car primitive-procedures))
  (define (primitive-procedure-objects)
    (map (lambda (proc)
           (list 'primitive (cdr proc)))
         primitive-procedures))

  (define (setup-environment)
    ((lambda (initial-env)        
       (define-variable! 'quote quote initial-env)
       (define-variable! 'lambda lambda initial-env)
       (define-variable! 'define define initial-env)
       (define-variable! 'set! set! initial-env)
       (define-variable! 'if if initial-env)
       (define-variable! 'begin begin initial-env)
       (define-variable! 'and and initial-env)
       (define-variable! 'or or initial-env)
       (define-variable! 'load load initial-env)
       initial-env)
     (extend-environment
      (primitive-procedure-names)
      (primitive-procedure-objects)
      the-empty-environment)))
  
  (define the-global-environment (setup-environment))

  (define input-prompt "> ")
  (define output-prompt "=> ")
  (define input-port (current-input-port))
  (define output-port (current-output-port))   
  (define (driver-loop)
    (prompt-for-input input-prompt)
    ((lambda (input)
       ((lambda (output)
          (announce-output output-prompt)
          (user-print output))
        (eval input the-global-environment)))
     (read input-port))
    (driver-loop))
  (define (prompt-for-input string)
    (display string output-port))
  (define (announce-output string)
    (display string output-port))
  (define (user-print object)
    (if (error-object? object)
        (begin
          (display "Error: ")
          (if (not (eq? (error-object-message object)) '||)
              (display " "))
          (display (error-object-message object))
          (define (iter objs)
            (if (not (c-null? objs))
                (begin (display " ")
                       (write (car objs))
                       (iter (cdr objs)))))
          (iter (error-irritants object)))
        (if (primitive-procedure? object)
            (display '|#<primitive-procedure>| output-port)
            (if (compound-procedure? object)
                (begin (display '|#<compound-procedure | output-port)
                       (write (procedure-parameters object) output-port)
                       (write '> output-port))
                (write object output-port))))
    (newline output-port))


  (eval '(begin
           (load "./lib/stdlib/base/compound_procedures.scm")
           (load "./lib/stdlib/char/compound_procedures.scm")
           (load "./lib/stdlib/cxr/compound_procedures.scm")
           )
        the-global-environment)
           
  (driver-loop)
  )
