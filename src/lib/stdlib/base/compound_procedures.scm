(begin
  (define (assoc obj alist . args)
    (define cmp (if (null? args)
                    (car args)
                    equal?))
    (define (iter alist)
      (if (null? alist)
          #f
          (if (cmp (car (car alist)) obj)
              (car alist)
              (iter (cdr alist)))))
    (iter alist))
  (define (assq obj alist) (assoc obj alist eq?))
  (define (assv obj alist) (assoc obj alist eqv?))
  
  (define (bytevector-copy! to at from . args)
    (define len (length args))
    (define start (if (= len 0) 0 (car args)))
    (define end (if (= len 2) (cadr args) (bytevector-length from)))
    (define (iter i j)
      (if (< j end)
          (begin
            (bytevector-u8-set! to i (bytevector-u8-ref from j))
            (iter (+ i 1) (+ j 1)))))
    (iter at start))
  
  (define (caar pair) (car (car pair)))
  (define (cadr pair) (car (cdr pair)))
  (define (cdar pair) (cdr (car pair)))
  (define (cddr pair) (cdr (cdr pair)))

  (define (equal? obj-1 obj-2)
    (if (and (pair? obj-1) (pair? obj-2))
        (and (equal? (car obj-1) (car obj-2)) (equal? (cdr obj-1) (cdr obj-2)))
        (if (and (vector? obj-1) (vector? obj-2))
            (equal? (vector->list obj-1) (vector->list obj-2))
            (if (and (string? obj-1) (string? obj-2))
                (equal? (string->list obj-1) (string->list obj-2))
                (if (and (bytevector? obj-1) (bytevector? obj-2))
                    (equal? (utf8->string obj-1) (utf8->string obj-2))
                    (eqv? obj-1 obj-2))))))

  (define (exact-integer? z)
    (and (number? z) (exact? z) (integer? z)))

  (define (floor-quotient n1 n2) (floor (/ n1 n2)))
  (define (floor-remainder n1 n2) (- n1 (* (floor-quotient n1 n2) n2)))

  (define (for-each proc list . list-of-list)
    (define (iter-1 list-of-list)
      (if (not (null? list-of-list))
          (begin
            (apply proc (car list-of-list))
            (iter-1 (cdr list-of-list)))))
    (define (cxrs cxr list-of-list)
      (if (null? list-of-list)
          '()
          (cons (cxr (car list-of-list))
                (cxrs cxr (cdr list-of-list)))))
    (define (list->list list-of-list)
      (if (memq '() list-of-list)
          '()
          (cons (cxrs car list-of-list)
                (list->list (cxrs cdr list-of-list)))))
    (iter-1 (list->list (cons list list-of-list))))

  (define (inexact? z) (not (exact? z)))

  (define (list-copy obj)
    (if (pair? obj)
        (begin
          (define (iter pair)
            (if (pair? pair)
                (cons (car pair)
                      (iter (cdr pair)))
                pair))
          (iter obj))
        obj))

  (define (list-ref list k)
    (define (iter list i)
      (if (= i k)
          (car list)
          (iter (cdr list) (+ i 1))))
    (iter list 0))

  (define (list-set! list k obj)
    (define (iter list i)
      (if (= i k)
          (set-car! list obj)
          (iter (cdr list) (+ i 1))))
    (iter list 0))

  (define (list-tail list k)
    (if (= k 0)
        list
        (list-tail (cdr list) (- k 1))))

  (define (map proc list . list-of-list)
    (define (iter-1 list-of-list)
      (if (null? list-of-list)
          '()
          (cons (apply proc (car list-of-list))
                (iter-1 (cdr list-of-list)))))
    (define (cxrs cxr list-of-list)
      (if (null? list-of-list)
          '()
          (cons (cxr (car list-of-list))
                (cxrs cxr (cdr list-of-list)))))
    (define (list->list list-of-list)
      (if (memq '() list-of-list)
          '()
          (cons (cxrs car list-of-list)
                (list->list (cxrs cdr list-of-list)))))
    (iter-1 (list->list (cons list list-of-list))))

  (define (max x . xs)
    (define (iter x xs)
      (if (null? xs)
          x
          (if (< x (car xs))
              (iter (car xs) (cdr xs))
              (iter x (cdr xs)))))
    (iter x xs))

  (define (member obj list compare)
    (if (null? list)
        #f
        (if (compare obj (car list))
            list
            (member obj (cdr list) compare))))
  
  (define (memq obj list) (member obj list eq?))

  (define (memv obj list) (member obj list memv))

  (define (min x . xs)
    (define (iter x xs)
      (if (null? xs)
          x
          (if (< x (car xs))
              (iter x (cdr xs))
              (iter (car xs) (cdr xs)))))
    (iter x xs))

  (define (not obj) (if obj #f #t))  

  (define (number->string z . args)
    (define radix (if (null? args)
                      10
                      (car args)))
    (define (digits->char n)
      (if (< n 10)
          (integer->char (+ n (char->integer #\0)))
          (integer->char (+ (- n 10) (char->integer #\a)))))
    (define (iter z i result)
      (if (= z 0)
          (list->string result)
          (iter (- z (remainder z (expt radix (+ i 1))))
                (+ i 1)
                (cons (digits->char (/ (remainder z (expt radix (+ i 1))) (expt radix i)))
                      result))))
    (iter (- z (remainder z radix))
          1
          (list (digits->char (+ (remainder z radix))))))

  (define (rationalize x y)
    (define diff (abs y))           
    (define low (- x diff))
    (define high (+ x diff))
    (define proc (if (and (exact? x) (exact? y)) exact inexact))
    (if (<= (* low high) 0)
        (proc 0)
        (if (= low high)
            (proc low)
            (begin
              (define sign (if (positive? x) 1 -1))
              (define low0 (if (positive? sign) low (abs high)))
              (define high0 (if (positive? sign) high (abs low)))
              (define (between? x) (and (<= low0 x) (<= x high0)))
              (define (stern-brocot-tree pnum pden qnum qden)
                (define a (/ (+ pnum qnum)
                             (+ pden qden)))
                (if (between? a)
                    a
                    ((lambda ()
                       (define num (numerator a))
                       (define den (denominator a))
                       (if (< high0 a)
                           (stern-brocot-tree pnum pden
                                              num den)
                           (stern-brocot-tree num den
                                              qnum qden))))))
              (proc (* sign (stern-brocot-tree 0 1 1 0)))))))

  (define (read-line . args)
    (define port (if (null? args)
                     (current-input-port)
                     (car args)))
    (define (iter result)
      (define char (read-char port))
      (if (eof-object? char)
          (eof-object)
          (if (or (eq? char #\newline)
                  (eq? char #\return))
              (list->string (reverse result))
              (iter (cons char result)))))
    (iter '()))

  (define (read-string k . args)
    (define port (if (null? args)
                     (current-input-port)
                     (car args)))
    (if (= k 0)
        ""
        (begin
          (define char (read-char port))
          (if (eof-object? char)
              (eof-object)
              (begin
                (define (iter i result)
                  (if (= i k)
                      (list->string (reverse result))
                      (begin
                        (define char (read-char port))
                        (if (eof-object? char)
                            (list->string (reverse result))
                            (iter (+ i 1) (cons char result))))))
                (iter 1 (cons char '())))))))

  (define (string . list-of-char) (list->string list-of-char))

  (define (string-append . list-of-string)
    (list->string (apply append (map string->list list-of-string))))

  (define (string-copy string . args)
    (define len (length args))
    (define start (if (< 0 len)
                      (car args)
                      0))
    (define end (if (= len 2)
                    (cadr args)
                    (string-length string)))
    (define (iter list-of-char i result)
      (if (= end i)
          (list->string (reverse result))
          (if (<= start i)
              (iter (cdr list-of-char)
                    (+ i 1)
                    (cons (car list-of-char)
                          result))
              (iter (cdr list-of-char)
                    (+ i 1)
                    result))))
    (iter (string->list string) 0 '()))

  (define (string-copy! to at from . args)
    (define len (length args))
    (define start (if (< 0 len)
                      (car args)
                      0))
    (define end (if (= len 2)
                    (cadr args)
                    (string-length from)))
    (define (iter i j)
      (if (< i end)
          (begin
            (string-set! to j (string-ref from i))
            (iter (+ i 1) (+ j 1)))))
    (iter start at))

  (define (string-fill! string fill . args)
    (define len (length args))
    (define start (if (< 0 len)
                      (car args)
                      0))
    (define end (if (= len 2)
                    (cadr args)
                    (string-length string)))
    (define (iter i)
      (if (< i end)
          (begin
            (string-set! string i fill)
            (iter (+ i 1)))))
    (iter start))

  (define (string-for-each proc string . list-of-string)
    (define (iter-1 list-of-list)
      (if (not (null? list-of-list))
          (begin
            (apply proc (car list-of-list))
            (iter-1 (cdr list-of-list)))))
    (define (cxrs cxr list-of-list)
      (if (null? list-of-list)
          '()
          (cons (cxr (car list-of-list))
                (cxrs cxr (cdr list-of-list)))))
    (define (list->list list-of-list)
      (if (memq '() list-of-list)
          '()
          (cons (cxrs car list-of-list)
                (list->list (cxrs cdr list-of-list)))))
    (iter-1 (list->list (map string->list (cons string list-of-string)))))

  (define (string-map proc string . list-of-string)
    (define (iter-1 list-of-list)
      (if (null? list-of-list)
          '()
          (cons (apply proc (car list-of-list))
                (iter-1 (cdr list-of-list)))))
    (define (cxrs cxr list-of-list)
      (if (null? list-of-list)
          '()
          (cons (cxr (car list-of-list))
                (cxrs cxr (cdr list-of-list)))))
    (define (list->list list-of-list)
      (if (memq '() list-of-list)
          '()
          (cons (cxrs car list-of-list)
                (list->list (cxrs cdr list-of-list)))))
    (list->string (iter-1 (list->list (map string->list (cons string list-of-string))))))

  (define (truncate-quotient n1 n2) (truncate (/ n1 n2)))
  (define (truncate-remainder n1 n2) (- n1 (* (truncate-quotient n1 n2) n2)))

  (define (zero? z) (= z 0))
  )

